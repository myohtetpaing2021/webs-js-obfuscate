<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Googlax Animated Sticker Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Libraries for capturing animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://unpkg.com/ccapture.js@1.1.0/build/CCapture.all.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #e8eaed;
        }
        .container-wrapper {
            background-color: #202124;
            border-radius: 1rem;
            padding: 2rem;
            width: 512px;
            height: 512px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border: 1px solid #5f6368;
        }
        .googlax-logo span {
            font-weight: 700;
            font-size: 5rem; /* Adjusted for container */
        }
        .g { color: #4285F4; }
        .o1 { color: #EA4335; }
        .o2 { color: #FBBC05; }
        .g2 { color: #4285F4; }
        .l { color: #34A853; }
        .a { color: #EA4335; }
        .x { color: #FBBC05; }

        .search-container {
            border: 1px solid #5f6368;
            border-radius: 9999px;
            display: flex;
            align-items: center;
            padding: 0.75rem 1.25rem;
            width: 100%;
            max-width: 450px; /* Adjusted for container */
        }

        .search-text {
            color: #e8eaed;
            font-size: 1rem;
            min-height: 1.5rem; /* To prevent layout shift */
            white-space: pre;
        }

        .cursor {
            display: inline-block;
            width: 2px;
            height: 1.2rem;
            background-color: #e8eaed;
        }
        
        .blinking-cursor {
             animation: blink 1s step-end infinite;
        }

        @keyframes blink {
            from, to { background-color: transparent; }
            50% { background-color: #e8eaed; }
        }

        .action-button {
            background-color: #303134;
            color: #e8eaed;
            border: 1px solid #5f6368;
            border-radius: 4px;
            padding: 0.5rem 1rem;
            margin: 0;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .action-button:hover {
            background-color: #404144;
        }
        .action-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .action-button .loader {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #5f6368;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: none; /* Hidden by default */
            margin-right: 8px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }


        .input-field {
            background-color: #303134;
            border: 1px solid #5f6368;
            border-radius: 4px;
            padding: 0.5rem 1rem;
            color: #e8eaed;
            width: 100%;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Sticker Container -->
    <div id="sticker-container" class="container-wrapper mb-6">
        <!-- Googlax Logo -->
        <h1 class="googlax-logo mb-6">
            <span class="g">G</span><span class="o1">o</span><span class="o2">o</span><span class="g2">g</span><span class="l">l</span><span class="a">a</span><span class="x">x</span>
        </h1>

        <!-- Search Bar -->
        <div class="search-container mb-3">
            <svg class="w-5 h-5 text-gray-400 mr-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0-0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
            <span id="typing-text" class="search-text"></span>
            <span id="cursor" class="cursor blinking-cursor"></span>
        </div>

        <!-- Buttons inside sticker -->
        <div id="sticker-buttons-container" class="flex justify-center w-full space-x-2">
            <button id="search-btn-sticker" class="action-button text-sm">Googlax Search</button>
            <button id="feeling-btn-sticker" class="action-button text-sm">I'm Feeling Glaxy</button>
        </div>
    </div>

    <!-- Controls -->
    <div class="w-full max-w-md p-4 bg-[#202124] rounded-lg border border-solid border-[#5f6368]">
        <label for="text-input" class="block mb-2 text-sm font-medium">Enter your text here:</label>
        <div class="flex items-center space-x-2 mb-4">
            <span class="text-gray-400">/googlax</span>
            <input type="text" id="text-input" class="input-field" value="" placeholder="your text here...">
        </div>
        <div class="flex space-x-2">
            <button id="start-btn" class="action-button w-1/2">Preview Animation</button>
            <button id="download-btn" class="action-button w-1/2 flex items-center justify-center">
                 <div class="loader"></div>
                 <span>Download</span>
            </button>
        </div>
    </div>

    <script>
        const typingElement = document.getElementById('typing-text');
        const cursorElement = document.getElementById('cursor');
        const textInput = document.getElementById('text-input');
        const startBtn = document.getElementById('start-btn');
        const downloadBtn = document.getElementById('download-btn');
        const stickerContainer = document.getElementById('sticker-container');
        const stickerButtonsContainer = document.getElementById('sticker-buttons-container');
        const searchBtnSticker = document.getElementById('search-btn-sticker');
        const feelingBtnSticker = document.getElementById('feeling-btn-sticker');

        let typeInterval;

        function playLoopingAnimation(textToType) {
            let charIndex = 0;
            typingElement.textContent = '';
            cursorElement.classList.add('blinking-cursor');

            if (typeInterval) clearInterval(typeInterval);
            
            const typingSpeed = 80;

            const type = () => {
                if (charIndex < textToType.length) {
                    typingElement.textContent += textToType.charAt(charIndex);
                    charIndex++;
                } else {
                    clearInterval(typeInterval);
                    setTimeout(() => playLoopingAnimation(textToType), 1500);
                }
            };
            typeInterval = setInterval(type, typingSpeed);
        }

        startBtn.addEventListener('click', () => {
            const text = textInput.value;
            playLoopingAnimation(text);
        });

        function drawRoundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.arcTo(x + width, y, x + width, y + radius, radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
            ctx.lineTo(x + radius, y + height);
            ctx.arcTo(x, y + height, x, y + height - radius, radius);
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.closePath();
        }

        // --- Download Feature ---
        downloadBtn.addEventListener('click', async () => {
            const text = textInput.value;

            const loader = downloadBtn.querySelector('.loader');
            const btnText = downloadBtn.querySelector('span');

            downloadBtn.disabled = true;
            loader.style.display = 'inline-block';
            btnText.textContent = 'Preparing...';
            
            // Allow UI to update before heavy processing
            await new Promise(resolve => setTimeout(resolve, 20));

            typingElement.style.visibility = 'hidden';
            cursorElement.style.visibility = 'hidden';
            stickerButtonsContainer.style.visibility = 'hidden';
            const bgCanvas = await html2canvas(stickerContainer, { backgroundColor: null, logging: false });
            typingElement.style.visibility = 'visible';
            cursorElement.style.visibility = 'visible';
            stickerButtonsContainer.style.visibility = 'visible';

            const stickerRect = stickerContainer.getBoundingClientRect();
            const textRect = typingElement.getBoundingClientRect();
            const cursorRect = cursorElement.getBoundingClientRect();
            const searchContainer = stickerContainer.querySelector('.search-container');
            const searchContainerRect = searchContainer.getBoundingClientRect();
            const textStartX = textRect.left - stickerRect.left;
            const searchCenterY = (searchContainerRect.top - stickerRect.top) + (searchContainerRect.height / 2);
            const textY = searchCenterY;
            const cursorHeight = cursorRect.height;
            const cursorY = searchCenterY - (cursorHeight / 2);
            const cursorWidth = cursorRect.width;

            const getButtonProps = (buttonElement) => {
                const style = window.getComputedStyle(buttonElement);
                const rect = buttonElement.getBoundingClientRect();
                return { x: rect.left - stickerRect.left, y: rect.top - stickerRect.top, width: rect.width, height: rect.height, text: buttonElement.textContent, bgColor: style.backgroundColor, borderColor: style.borderColor, borderWidth: parseInt(style.borderWidth, 10), borderRadius: parseInt(style.borderRadius, 10), textColor: style.color, font: `${style.fontSize} ${style.fontFamily}`};
            };
            
            const searchBtnProps = getButtonProps(searchBtnSticker);
            const feelingBtnProps = getButtonProps(feelingBtnSticker);

            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = 512;
            offscreenCanvas.height = 512;
            const ctx = offscreenCanvas.getContext('2d');

            const computedStyle = window.getComputedStyle(typingElement);
            ctx.font = `${computedStyle.fontWeight} ${computedStyle.fontSize} ${computedStyle.fontFamily}`;
            ctx.fillStyle = computedStyle.color;
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'left';

            btnText.textContent = 'Recording...';
            await new Promise(resolve => setTimeout(resolve, 20));
            
            const framerate = 30;
            const capturer = new CCapture({
                format: 'webm',
                framerate: framerate,
                verbose: false,
                quality: 99,
            });
            
            // --- The Definitive Fix ---
            const msPerFrame = 1000 / framerate;
            const typingSpeed = 60; 
            const pauseDuration = 1000;
            let typingDuration = text.length * typingSpeed;
            
            let totalDuration = typingDuration + pauseDuration;
            if (totalDuration > 3000) {
                totalDuration = 3000;
                typingDuration = Math.max(0, totalDuration - pauseDuration);
            }
            
            const totalFrames = Math.ceil(totalDuration / msPerFrame);
            
            capturer.start();
            
            let currentFrame = 0;
            function renderLoop() {
                if (currentFrame > totalFrames) {
                    btnText.textContent = 'Saving...';
                    capturer.stop();
                    capturer.save(blob => {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'googlax-sticker.webm';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        downloadBtn.disabled = false;
                        loader.style.display = 'none';
                        btnText.textContent = 'Download';
                    });
                    return; 
                }

                const currentTime = currentFrame * msPerFrame;
                const charsTyped = typingSpeed > 0 ? Math.floor(currentTime / typingSpeed) : text.length;
                const charsToShow = Math.min(charsTyped, text.length);
                const currentText = text.substring(0, charsToShow);

                ctx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
                ctx.drawImage(bgCanvas, 0, 0);
                
                [searchBtnProps, feelingBtnProps].forEach(props => {
                    ctx.lineWidth = props.borderWidth;
                    ctx.strokeStyle = props.borderColor;
                    ctx.fillStyle = props.bgColor;
                    drawRoundedRect(ctx, props.x, props.y, props.width, props.height, props.borderRadius);
                    ctx.fill(); ctx.stroke();
                    ctx.fillStyle = props.textColor;
                    ctx.font = props.font;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(props.text, props.x + props.width / 2, props.y + props.height / 2);
                });

                ctx.textAlign = 'left';
                ctx.fillStyle = computedStyle.color;
                ctx.font = `${computedStyle.fontWeight} ${computedStyle.fontSize} ${computedStyle.fontFamily}`;
                ctx.fillText(currentText, textStartX, textY);
                
                const textMetrics = ctx.measureText(currentText);
                const currentCursorX = textStartX + textMetrics.width;
                const isTypingFinished = currentTime >= typingDuration;
                
                if (isTypingFinished) {
                     if (Math.floor((currentTime - typingDuration) / 500) % 2 === 0) {
                        ctx.fillRect(currentCursorX, cursorY, cursorWidth, cursorHeight);
                    }
                } else {
                     ctx.fillRect(currentCursorX, cursorY, cursorWidth, cursorHeight);
                }
               
                capturer.capture(offscreenCanvas);
                currentFrame++;
                requestAnimationFrame(renderLoop); 
            }

            renderLoop(); // Start the guaranteed animation loop
        });

        playLoopingAnimation(""); // Start with empty animation
    </script>

</body>
</html>

